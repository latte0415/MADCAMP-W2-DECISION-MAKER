# 배포 가이드라인

> **목적**: 실시간 다인원 공동 작업 플랫폼의 안정적인 배포를 위한 기술 가이드라인
> 
> **배포 환경 가정**: 사용자 100명 동시 접속
> 
> **프로젝트 특성**: 의사결정 플랫폼 (제안/투표/승인)
> - 여러 사용자가 동시에 투표/제안/승인 작업 수행
> - 네트워크 지연 및 재시도로 인한 중복 요청 발생 가능
> - 데이터 정합성과 동시성 제어가 매우 중요

---

## 1. 실시간 동기화 전략

### 1.1 현재 상황 분석

**실시간 업데이트가 필요한 시나리오:**
- ⭐⭐⭐ 제안 투표 수 실시간 반영
- ⭐⭐⭐ 제안 승인/기각 상태 변경
- ⭐⭐⭐ 자동 승인 (투표 수 임계값 도달)
- ⭐⭐ 새로운 제안 생성
- ⭐⭐ 코멘트 추가

**사용자 100명 환경:**
- Polling (3초 간격): 초당 약 33개 요청 → **부적합**
- SSE: 연결당 1초마다 DB 체크 → **권장**
- WebSocket: 양방향 통신 필요 시 → **선택적**

### 1.2 권장 구현: SSE (Server-Sent Events) ⭐

**이유:**
- 사용자 100명 환경에 적합
- 구현이 WebSocket보다 간단
- 단방향 통신(서버→클라이언트)에 최적
- HTTP 기반 (방화벽/프록시 친화적)

**구현 방법:**

```python
# app/routers/event/stream.py
from fastapi import APIRouter, Depends
from fastapi.responses import StreamingResponse
from sqlalchemy.orm import Session
import asyncio
import json
from datetime import datetime

router = APIRouter(prefix="/events", tags=["events"])

@router.get("/{event_id}/stream")
async def stream_event_updates(
    event_id: UUID,
    db: Session = Depends(get_db)
):
    """SSE 스트림으로 이벤트 업데이트 전송"""
    
    async def event_generator():
        last_check = datetime.now()
        
        while True:
            try:
                # DB에서 변경사항 확인
                updates = check_event_updates(db, event_id, last_check)
                
                if updates:
                    yield f"data: {json.dumps(updates)}\n\n"
                    last_check = datetime.now()
                
                await asyncio.sleep(1)  # 1초마다 체크
                
            except Exception as e:
                yield f"event: error\ndata: {json.dumps({'error': str(e)})}\n\n"
                await asyncio.sleep(5)  # 에러 시 5초 대기
    
    return StreamingResponse(
        event_generator(),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "Connection": "keep-alive",
        }
    )
```

**프론트엔드 구현:**

```javascript
// hooks/useEventStream.ts
const eventSource = new EventSource(`/api/events/${eventId}/stream`);

eventSource.onmessage = (event) => {
  const data = JSON.parse(event.data);
  // UI 업데이트
  updateEventData(data);
};

eventSource.onerror = (error) => {
  console.error('SSE error:', error);
  // 재연결 로직
};
```

**성능 최적화:**
- Redis Pub/Sub으로 변경사항 브로드캐스트 (여러 서버 인스턴스 시)
- 변경사항이 있을 때만 클라이언트에 전송
- 연결 해제 시 자동 정리

### 1.3 WebSocket 고려 시점

**다음 경우에 WebSocket으로 전환 고려:**
- 양방향 실시간 통신이 필요한 기능 추가 시
- 사용자 수가 500명 이상 증가 시
- 지연시간이 100ms 이하로 필요한 시나리오 추가 시

---

## 2. 데이터 정합성 보장

### 2.1 현재 구현 상태

**✅ 이미 구현된 항목:**
- UNIQUE 제약 (중복 투표 방지)
- 조건부 업데이트 (자동 승인 시 중복 방지)

**❌ 개선이 필요한 항목:**
- 트랜잭션 명시적 관리
- Row-level Lock (관리자 수동 승인 시)
- Idempotency (중복 요청 방지)
- 상태 전이 검증 강화

### 2.2 Phase 1: 트랜잭션 명시적 관리 ⭐ (최우선)

**목표:** 모든 중요한 작업을 명시적 트랜잭션으로 감싸기

**구현:**

```python
# app/utils/transaction.py
from contextlib import contextmanager
from sqlalchemy.orm import Session

@contextmanager
def transaction(db: Session):
    """트랜잭션 컨텍스트 매니저"""
    try:
        yield db
        db.commit()
    except Exception:
        db.rollback()
        raise
```

**적용 위치:**
- `ProposalService.create_assumption_proposal()`
- `ProposalService.create_assumption_proposal_vote()`
- `ProposalService.update_assumption_proposal_status()` (관리자 승인)
- 모든 proposal 생성/투표/승인 메서드
- `MembershipService.approve_membership()` 등

**예시:**

```python
def create_assumption_proposal_vote(...):
    with transaction(self.db):
        # 투표 생성
        vote = AssumptionProposalVote(...)
        created_vote = self.repos.proposal.create_assumption_proposal_vote(vote)
        
        # 자동 승인 체크
        self._check_and_auto_approve_assumption_proposal(proposal, event)
        # 트랜잭션 끝에서 자동 commit (또는 예외 시 rollback)
```

**예상 소요 시간:** 2-3시간

---

### 2.3 Phase 2: Row-level Lock 추가 ⭐ (필수)

**목표:** 관리자 수동 승인 시 동시성 방어

**문제:**
- 현재 `update_assumption_proposal_status()` 메서드에서 락 없이 조회 후 업데이트
- 동시에 여러 관리자가 같은 proposal 승인 시도 시 모두 성공 가능

**구현:**

```python
# app/repositories/proposal/generic.py
def get_proposal_by_id_with_lock(
    self,
    proposal_id: UUID,
    proposal_class: Type[ProposalType],
    relationships: list[str] | None = None
) -> ProposalType | None:
    """락을 걸고 proposal 조회"""
    stmt = (
        select(proposal_class)
        .where(proposal_class.id == proposal_id)
        .with_for_update()  # Row-level lock
    )
    if relationships:
        for rel in relationships:
            stmt = stmt.options(joinedload(getattr(proposal_class, rel)))
    result = self.db.execute(stmt)
    return result.unique().scalar_one_or_none()
```

**서비스 레이어 적용:**

```python
# app/services/event/proposal_service.py
def update_assumption_proposal_status(...):
    with transaction(self.db):
        # 락을 걸고 조회
        proposal = self.repos.proposal.get_assumption_proposal_by_id_with_lock(
            proposal_id, AssumptionProposal
        )
        # ... 나머지 로직
```

**적용 위치:**
- `update_assumption_proposal_status()` (모든 proposal 타입)
- `MembershipService.approve_membership()` (멤버십 승인)
- `MembershipService.reject_membership()` (멤버십 거절)

**예상 소요 시간:** 3-4시간

---

### 2.4 Phase 3: Idempotency 구현 ⭐ (중요)

**목표:** 중복 요청 방지 (버튼 연타, 네트워크 재시도)

**구현:**

```python
# app/models/idempotency.py
class IdempotencyKey(Base):
    __tablename__ = "idempotency_keys"
    
    id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), primary_key=True)
    idempotency_key: Mapped[str] = mapped_column(String(255), unique=True, nullable=False)
    request_path: Mapped[str] = mapped_column(String(255), nullable=False)
    request_method: Mapped[str] = mapped_column(String(10), nullable=False)
    user_id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), nullable=False)
    response_status: Mapped[int] = mapped_column(Integer, nullable=False)
    response_body: Mapped[str] = mapped_column(Text, nullable=True)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False)
    
    __table_args__ = (
        UniqueConstraint("idempotency_key", name="uq_idempotency_keys_key"),
        Index("idx_idempotency_keys_user", "user_id"),
    )
```

```python
# app/utils/idempotency.py
from functools import wraps
from fastapi import Request, HTTPException, Response
from sqlalchemy.orm import Session
import json

def idempotent(db: Session):
    """Idempotency 데코레이터"""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # idempotency_key 추출 (헤더: Idempotency-Key)
            request: Request = kwargs.get('request')
            if not request:
                # request가 없는 경우 건너뛰기
                return await func(*args, **kwargs)
            
            idempotency_key = request.headers.get('Idempotency-Key')
            if not idempotency_key:
                return await func(*args, **kwargs)
            
            # 기존 처리 확인
            existing = db.query(IdempotencyKey).filter(
                IdempotencyKey.idempotency_key == idempotency_key
            ).first()
            
            if existing:
                # 기존 응답 반환
                return Response(
                    content=existing.response_body,
                    status_code=existing.response_status,
                    media_type="application/json"
                )
            
            # 처리 실행
            try:
                result = await func(*args, **kwargs)
                # 응답 저장 (트랜잭션 내에서)
                # ...
                return result
            except Exception as e:
                # 에러는 저장하지 않음
                raise
        
        return wrapper
    return decorator
```

**적용 위치:**
- `POST /events/{event_id}/assumption-proposals/{proposal_id}/votes`
- `POST /events/{event_id}/criteria-proposals/{proposal_id}/votes`
- `POST /events/{event_id}/conclusion-proposals/{proposal_id}/votes`
- `PATCH /events/{event_id}/assumption-proposals/{proposal_id}/status` (관리자 승인)
- `PATCH /events/{event_id}/memberships/{membership_id}/approve`

**예상 소요 시간:** 4-5시간

---

### 2.5 Phase 4: 상태 전이 검증 강화

**목표:** 허용된 상태 전이만 처리하도록 강제

**구현:**

```python
# app/utils/state_transition.py
from app.models.proposal import ProposalStatusType

ALLOWED_PROPOSAL_TRANSITIONS = {
    ProposalStatusType.PENDING: [
        ProposalStatusType.ACCEPTED,
        ProposalStatusType.REJECTED,
        ProposalStatusType.DELETED
    ],
    # ACCEPTED, REJECTED, DELETED는 더 이상 전이 불가
}

def validate_proposal_transition(
    current_status: ProposalStatusType,
    new_status: ProposalStatusType
) -> None:
    """상태 전이 검증"""
    allowed = ALLOWED_PROPOSAL_TRANSITIONS.get(current_status, [])
    if new_status not in allowed:
        from app.exceptions import ValidationError
        raise ValidationError(
            message="Invalid state transition",
            detail=f"Cannot transition from {current_status} to {new_status}"
        )
```

**서비스 레이어 적용:**

```python
def update_assumption_proposal_status(...):
    with transaction(self.db):
        proposal = self.repos.proposal.get_assumption_proposal_by_id_with_lock(
            proposal_id, AssumptionProposal
        )
        current_status = proposal.proposal_status
        
        # 상태 전이 검증
        validate_proposal_transition(current_status, status)
        
        # 상태 변경
        proposal.proposal_status = status
        # ...
```

**예상 소요 시간:** 2-3시간

---

## 3. 성능 최적화

### 3.1 데이터베이스 인덱스 검토

**확인할 주요 쿼리:**
- Proposal 목록 조회 (event_id로 필터링)
- Vote 수 집계 쿼리
- Membership 조회 (event_id, user_id로 필터링)

**방법:**
```sql
EXPLAIN ANALYZE SELECT ...;
```

**예상 소요 시간:** 3-4시간

---

## 4. 구현 우선순위

### 최우선 (1주차)
1. **SSE 구현** (실시간 동기화)
2. **트랜잭션 명시적 관리** (데이터 정합성)
3. **Row-level Lock 추가** (동시성 방어)

**총 예상 시간:** 8-10시간

### 중요 (2주차)
4. **Idempotency 구현** (중복 요청 방지)
5. **상태 전이 검증 강화** (데이터 무결성)
6. **성능 최적화** (인덱스 검토)

**총 예상 시간:** 9-12시간

### 선택 (3주차 이후)
7. **WebSocket 전환** (필요 시)
8. **Outbox 패턴** (비동기 작업 처리)

---

## 5. 테스트 전략

### 5.1 동시성 테스트

**목적:** 여러 사용자가 동시에 같은 작업을 수행할 때 데이터 정합성 확인

**방법:**
```python
import asyncio
import aiohttp

async def test_concurrent_votes():
    async with aiohttp.ClientSession() as session:
        tasks = []
        for i in range(10):
            task = session.post(
                f"/events/{event_id}/assumption-proposals/{proposal_id}/votes",
                headers={"Authorization": f"Bearer {token_{i}}"},
                json={"idempotency_key": f"test_{i}"}
            )
            tasks.append(task)
        
        results = await asyncio.gather(*tasks)
        # 결과 검증: UNIQUE 제약으로 인해 중복 투표는 실패해야 함
```

### 5.2 Idempotency 테스트

**목적:** 같은 idempotency_key로 여러 번 요청 시 첫 번째 응답만 반환되는지 확인

**방법:**
```python
def test_idempotency():
    idempotency_key = "test_key_123"
    
    # 첫 번째 요청
    response1 = client.post(
        "/events/{event_id}/proposals/{proposal_id}/votes",
        headers={"Idempotency-Key": idempotency_key}
    )
    
    # 두 번째 요청 (동일한 키)
    response2 = client.post(
        "/events/{event_id}/proposals/{proposal_id}/votes",
        headers={"Idempotency-Key": idempotency_key}
    )
    
    # 응답이 동일해야 함
    assert response1.json() == response2.json()
    # DB에는 투표가 하나만 있어야 함
```

### 5.3 트랜잭션 롤백 테스트

**목적:** 예외 발생 시 트랜잭션이 롤백되는지 확인

**방법:**
```python
def test_transaction_rollback():
    # 예외를 발생시키는 요청
    with pytest.raises(Exception):
        client.post("/events/{event_id}/proposals", json={...})
    
    # DB 상태 확인: 변경사항이 롤백되었는지 확인
    # ...
```

---

## 6. 모니터링 포인트

### 6.1 실시간 동기화
- SSE 연결 수 모니터링
- 연결 해제/재연결 횟수
- 메시지 전송 지연 시간

### 6.2 데이터 정합성
- 트랜잭션 롤백 횟수
- Row-level Lock 대기 시간
- Idempotency 키 재사용 횟수

### 6.3 성능
- 주요 쿼리 실행 시간
- 인덱스 히트율
- 동시 접속자 수

---

## 7. 배포 체크리스트

### 실시간 동기화
- [ ] SSE 엔드포인트 구현
- [ ] 프론트엔드 EventSource 연결
- [ ] 연결 해제 시 자동 정리
- [ ] 에러 처리 및 재연결 로직

### 데이터 정합성
- [ ] 트랜잭션 컨텍스트 매니저 적용
- [ ] Row-level Lock 적용 (관리자 승인)
- [ ] Idempotency 구현 (주요 엔드포인트)
- [ ] 상태 전이 검증 강화

### 성능
- [ ] 주요 쿼리 EXPLAIN ANALYZE 실행
- [ ] 필요한 인덱스 추가
- [ ] 성능 테스트 (100명 동시 접속)

### 테스트
- [ ] 동시성 테스트
- [ ] Idempotency 테스트
- [ ] 트랜잭션 롤백 테스트
- [ ] 부하 테스트

---

## 8. 참고사항

### 8.1 Redis Pub/Sub 고려

**여러 서버 인스턴스 운영 시:**
- SSE 연결이 여러 서버에 분산됨
- Redis Pub/Sub으로 변경사항을 모든 서버에 브로드캐스트
- 각 서버가 연결된 클라이언트에게 메시지 전송

**구현:**
```python
import redis.asyncio as redis

redis_client = redis.Redis(...)

# 변경사항 발생 시
await redis_client.publish(f"event:{event_id}", json.dumps(updates))

# SSE 연결에서 구독
pubsub = redis_client.pubsub()
await pubsub.subscribe(f"event:{event_id}")

async for message in pubsub.listen():
    yield f"data: {message['data']}\n\n"
```

### 8.2 데이터베이스 연결 풀

**100명 동시 접속 환경:**
- DB 연결 풀 크기 설정: 최소 20-30개
- 연결 타임아웃 설정
- 연결 유지 시간 최적화

```python
engine = create_engine(
    DATABASE_URL,
    pool_size=20,
    max_overflow=10,
    pool_pre_ping=True,
    pool_recycle=3600
)
```

---

**작성일:** 2024년  
**최종 수정일:** 2024년  
**배포 환경:** 사용자 100명 동시 접속 가정
