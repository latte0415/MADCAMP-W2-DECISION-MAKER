# 트랜잭션 중심 백엔드 & 신뢰성 설계 가이드

> **목적**
> 이 문서는 1주 집중 프로젝트에서 **트랜잭션, 동시성, 중복 요청 방지, 비동기 처리, 신뢰성**을 실제로 구현하기 위해 반드시 알아야 할 개념과 표준 흐름을 정리한 가이드입니다.
> 비즈니스 도메인은 자유롭게 치환 가능하도록 기술 중심으로 서술합니다.

---

## 1. 핵심 문제 정의

실제 서비스에서 반드시 해결해야 하는 문제는 다음과 같습니다.

* 같은 요청이 **여러 번** 들어온다
* 같은 리소스를 **동시에** 여러 요청이 수정하려 한다
* 서버/프로세스는 **언제든지 죽을 수 있다**
* 외부 시스템(API, 알림, LLM)은 **느리고 자주 실패한다**

이 가이드는 위 문제를 **구조적으로 해결하는 방법**을 다룹니다.

---

## 2. 트랜잭션(Transaction)

### 2.1 개념

트랜잭션이란 **여러 작업을 하나의 묶음으로 처리**하는 장치입니다.

* 모두 성공 → `commit`
* 하나라도 실패 → `rollback`

즉, **전부 아니면 전무(All or Nothing)** 입니다.

### 2.2 왜 필요한가

예시:

* 상태 변경
* 로그/원장 기록
* 후속 작업 예약

이 중 하나라도 빠지면 데이터 정합성이 깨집니다.

---

## 3. 원자성(Atomicity)

### 3.1 개념

사용자 입장에서 작업은 항상 다음 중 하나여야 합니다.

* 완전히 성공
* 완전히 실패

중간 상태는 허용되지 않습니다.

### 3.2 실무적 의미

* 버튼을 눌렀는데 절반만 처리되는 상황 방지
* 결제/정산/확정/승인 계열 기능에 필수

---

## 4. 동시성(Concurrency) 문제

### 4.1 문제 상황

* 동일 리소스에 여러 요청이 동시에 접근
* 마지막 좌석, 마지막 포인트, 단일 상태 전이 등

### 4.2 해결 전략

#### 1) Row-level Lock

* `SELECT ... FOR UPDATE`
* 한 요청이 처리 중이면 다른 요청은 대기

#### 2) 조건부 업데이트

* `WHERE status = 'pending'`
* 동시에 와도 하나만 성공

#### 3) Unique Constraint

* DB가 중복을 직접 차단
* 서버는 실패를 해석만 하면 됨

---

## 5. 상태 전이(State Transition)

### 5.1 개념

엔티티는 **허용된 상태 흐름**만 따라야 합니다.

예:

* `pending → confirmed → settled`
* `draft → published → archived`

### 5.2 구현 원칙

* 상태 전이 규칙은 서버 로직에서 강제
* DB는 최종 방어선(제약 조건)

---

## 6. Idempotency (중복 요청 방지)

### 6.1 왜 필요한가

현실에서는 다음이 항상 발생합니다.

* 버튼 연타
* 네트워크 재시도
* 타임아웃 후 재요청

### 6.2 개념

같은 요청을 여러 번 보내도 **결과는 한 번만 반영**되도록 보장

### 6.3 구현 방식

* 요청마다 `idempotency_key` 포함
* 처리 이력을 DB에 저장
* 이미 처리된 키면 **기존 결과 반환**

> ⚠️ 반드시 트랜잭션 내부에서 처리

---

## 7. 비동기 처리 & 큐

### 7.1 분리해야 할 작업

* 알림/이메일 발송
* 외부 API 호출
* 리포트 생성
* LLM 호출

### 7.2 큐/워커 구조

* API 서버: 요청 검증 + 핵심 로직만 처리
* 워커: 큐에서 작업을 꺼내 비동기로 실행

### 7.3 효과

* API 응답 속도 개선
* 실패 격리
* 시스템 안정성 향상

---

## 8. Retry & DLQ

### 8.1 재시도(Retry)

* 외부 시스템 실패는 정상
* 일정 횟수/간격으로 재시도

### 8.2 실패 보관(DLQ 개념)

* 계속 실패하는 작업은 별도 보관
* 운영/수동 처리/재처리 가능

---

## 9. Outbox 패턴 (간이 버전)

### 9.1 문제

* DB는 커밋됐는데
* 큐에 작업을 넣기 전에 서버가 죽음

### 9.2 해결

* 트랜잭션 안에서 `outbox` 테이블에 작업 기록
* 워커가 outbox를 읽어 처리

### 9.3 핵심 효과

* 데이터 변경과 후속 작업 예약의 **일관성 보장**

---

## 10. 성능 분석: EXPLAIN

### 10.1 개념

DB가 쿼리를 어떻게 실행하는지 보여주는 실행 계획

### 10.2 활용법

* 인덱스 추가 전/후 비교
* 병목 원인 파악

### 10.3 과제 제출 포인트

* `EXPLAIN ANALYZE` 결과 캡처
* 인덱스 추가 근거 설명

---

## 11. 대표 안전 흐름(표준 패턴)

1. 요청 수신 (idempotency_key 포함)
2. DB 트랜잭션 시작
3. Idempotency 체크
4. 상태 확인 + 락
5. 상태 전이
6. 로그/원장 기록
7. Outbox 이벤트 저장
8. 트랜잭션 커밋
9. 즉시 응답
10. 워커가 후속 작업 처리

---

## 12. 1주 프로젝트 최소 체크리스트

* [ ] 트랜잭션으로 원자성 보장
* [ ] 동시성 방어(락/조건/unique 중 1개 이상)
* [ ] Idempotency 구현
* [ ] 비동기 작업 큐 분리
* [ ] Retry/실패 처리 전략
* [ ] EXPLAIN 기반 성능 개선 1건

---

## 13. 마무리

이 구조는 특정 기술이나 비즈니스에 종속되지 않습니다.

* 결제
* 예약
* 정산
* 승인
* 포인트
* 초대

어떤 도메인에도 그대로 적용 가능합니다.

> **핵심 메시지:**
> 복잡한 서비스의 본질은 기능이 아니라 **정합성과 신뢰성**이다.
