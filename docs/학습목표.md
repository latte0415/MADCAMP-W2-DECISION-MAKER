# 트랜잭션 중심 백엔드 & 신뢰성 설계 가이드

> **목적**
> 이 문서는 1주 집중 프로젝트에서 **트랜잭션, 동시성, 중복 요청 방지, 비동기 처리, 신뢰성**을 실제로 구현하기 위해 반드시 알아야 할 개념과 표준 흐름을 정리한 가이드입니다.
> 비즈니스 도메인은 자유롭게 치환 가능하도록 기술 중심으로 서술합니다.

---

## 1. 핵심 문제 정의

실제 서비스에서 반드시 해결해야 하는 문제는 다음과 같습니다.

* 같은 요청이 **여러 번** 들어온다
* 같은 리소스를 **동시에** 여러 요청이 수정하려 한다
* 서버/프로세스는 **언제든지 죽을 수 있다**
* 외부 시스템(API, 알림, LLM)은 **느리고 자주 실패한다**

이 가이드는 위 문제를 **구조적으로 해결하는 방법**을 다룹니다.

---

## 2. 트랜잭션(Transaction)

### 2.1 개념

트랜잭션이란 **여러 작업을 하나의 묶음으로 처리**하는 장치입니다.

* 모두 성공 → `commit`
* 하나라도 실패 → `rollback`

즉, **전부 아니면 전무(All or Nothing)** 입니다.

### 2.2 왜 필요한가

예시:

* 상태 변경
* 로그/원장 기록
* 후속 작업 예약

이 중 하나라도 빠지면 데이터 정합성이 깨집니다.

---

## 3. 원자성(Atomicity)

### 3.1 개념

사용자 입장에서 작업은 항상 다음 중 하나여야 합니다.

* 완전히 성공
* 완전히 실패

중간 상태는 허용되지 않습니다.

### 3.2 실무적 의미

* 버튼을 눌렀는데 절반만 처리되는 상황 방지
* 결제/정산/확정/승인 계열 기능에 필수

---

## 4. 동시성(Concurrency) 문제

### 4.1 문제 상황

* 동일 리소스에 여러 요청이 동시에 접근
* 마지막 좌석, 마지막 포인트, 단일 상태 전이 등

### 4.2 해결 전략

#### 1) Row-level Lock

* `SELECT ... FOR UPDATE`
* 한 요청이 처리 중이면 다른 요청은 대기

#### 2) 조건부 업데이트

* `WHERE status = 'pending'`
* 동시에 와도 하나만 성공

#### 3) Unique Constraint

* DB가 중복을 직접 차단
* 서버는 실패를 해석만 하면 됨

---

## 5. 상태 전이(State Transition)

### 5.1 개념

엔티티는 **허용된 상태 흐름**만 따라야 합니다.

예:

* `pending → confirmed → settled`
* `draft → published → archived`

### 5.2 구현 원칙

* 상태 전이 규칙은 서버 로직에서 강제
* DB는 최종 방어선(제약 조건)

---

## 6. Idempotency (중복 요청 방지)

### 6.1 왜 필요한가

현실에서는 다음이 항상 발생합니다.

* 버튼 연타
* 네트워크 재시도
* 타임아웃 후 재요청

### 6.2 개념

같은 요청을 여러 번 보내도 **결과는 한 번만 반영**되도록 보장

### 6.3 구현 방식

* 요청마다 `idempotency_key` 포함
* 처리 이력을 DB에 저장
* 이미 처리된 키면 **기존 결과 반환**

> ⚠️ 반드시 트랜잭션 내부에서 처리

---

## 7. 비동기 처리 & 큐

### 7.1 분리해야 할 작업

* 알림/이메일 발송
* 외부 API 호출
* 리포트 생성
* LLM 호출

### 7.2 큐/워커 구조

* API 서버: 요청 검증 + 핵심 로직만 처리
* 워커: 큐에서 작업을 꺼내 비동기로 실행

### 7.3 효과

* API 응답 속도 개선
* 실패 격리
* 시스템 안정성 향상

---

## 8. Retry & DLQ

### 8.1 재시도(Retry)

* 외부 시스템 실패는 정상
* 일정 횟수/간격으로 재시도

### 8.2 실패 보관(DLQ 개념)

* 계속 실패하는 작업은 별도 보관
* 운영/수동 처리/재처리 가능

---

## 9. Outbox 패턴 (간이 버전)

### 9.1 문제

* DB는 커밋됐는데
* 큐에 작업을 넣기 전에 서버가 죽음

### 9.2 해결

* 트랜잭션 안에서 `outbox` 테이블에 작업 기록
* 워커가 outbox를 읽어 처리

### 9.3 핵심 효과

* 데이터 변경과 후속 작업 예약의 **일관성 보장**

---

## 10. 성능 분석: EXPLAIN

### 10.1 개념

DB가 쿼리를 어떻게 실행하는지 보여주는 실행 계획

### 10.2 활용법

* 인덱스 추가 전/후 비교
* 병목 원인 파악

### 10.3 과제 제출 포인트

* `EXPLAIN ANALYZE` 결과 캡처
* 인덱스 추가 근거 설명

---

## 11. 대표 안전 흐름(표준 패턴)

1. 요청 수신 (idempotency_key 포함)
2. DB 트랜잭션 시작
3. Idempotency 체크
4. 상태 확인 + 락
5. 상태 전이
6. 로그/원장 기록
7. Outbox 이벤트 저장
8. 트랜잭션 커밋
9. 즉시 응답
10. 워커가 후속 작업 처리

---

## 12. 1주 프로젝트 최소 체크리스트

* [ ] 트랜잭션으로 원자성 보장
* [ ] 동시성 방어(락/조건/unique 중 1개 이상)
* [ ] Idempotency 구현
* [ ] 비동기 작업 큐 분리
* [ ] Retry/실패 처리 전략
* [ ] EXPLAIN 기반 성능 개선 1건

---

## 13. 프로젝트 단계별 구현 가이드

> **주의**: 한 번에 모든 Phase를 구현하지 마세요. 각 Phase를 완료하고 테스트한 후 다음 단계로 진행하세요.

### Phase 1: 기본 CRUD (초기 구현)

**목표**: Decision, Assumption, Criterion, Answer 생성/조회

**구현 내용:**
- POST /decisions - Decision 생성
- GET /decisions - Decision 목록 조회
- POST /assumptions - Assumption 생성
- GET /assumptions - Assumption 목록 조회
- POST /criteria - Criterion 생성
- GET /criteria - Criterion 목록 조회
- POST /answers - Answer 생성
- GET /answers - Answer 목록 조회

**적용할 학습목표:**
- 없음 (기본 CRUD 구현)

**테스트 포인트:**
- 각 엔드포인트의 정상 동작 확인
- 요청/응답 검증

---

### Phase 2: Proposal 시스템 (트랜잭션 시작)

**목표**: Assumption/Criteria/Conclusion 제안 생성/조회

**구현 내용:**
- POST /assumptions/proposals - Assumption 제안 생성
- GET /assumptions/proposals - Assumption 제안 목록
- POST /criteria/proposals - Criterion 제안 생성
- GET /criteria/proposals - Criterion 제안 목록
- POST /conclusions/proposals - Conclusion 제안 생성
- GET /conclusions/proposals - Conclusion 제안 목록

**적용할 학습목표:**
- **트랜잭션 (2장)**: 제안 생성 시 관련 로그/이력 기록
  - `assumption_proposals` INSERT와 함께 관련 이력 기록
  - 트랜잭션으로 원자성 보장

**테스트 포인트:**
- 제안 생성 시 정상 동작 확인
- 동시에 여러 제안 생성 시 데이터 정합성 확인
- 트랜잭션 실패 시 롤백 확인

---

### Phase 3: 투표 시스템 ⭐ (동시성 방어 시작 - 필수)

**목표**: Proposal/Answer에 투표 기능 구현

**구현 내용:**
- POST /assumptions/proposals/{id}/votes - Assumption 제안 투표
- POST /criteria/proposals/{id}/votes - Criterion 제안 투표
- POST /conclusions/proposals/{id}/votes - Conclusion 제안 투표
- POST /answers/{id}/votes - Answer 투표

**적용할 학습목표:**
1. **Unique Constraint (4.2.3)**: UNIQUE 제약으로 중복 투표 방지
   - `UNIQUE(proposal_id, created_by)` 제약 활용
   - 트랜잭션 내 INSERT → 실패 시 적절히 처리
2. **트랜잭션 (2장)**: 투표 + 이력 기록을 하나의 트랜잭션으로
3. **Idempotency (6장)**: 선택적으로 동일 요청 재처리 방지
   - `idempotency_key`를 활용한 중복 요청 처리

**테스트 포인트:**
- 동일 사용자의 중복 투표 시도 → 409 Conflict 확인
- 여러 사용자가 동시에 같은 proposal에 투표 → 정합성 확인
- `EXPLAIN ANALYZE`로 UNIQUE 인덱스 활용 확인

**Phase 3 체크리스트:**
- [ ] UNIQUE 제약으로 중복 투표 방지 구현
- [ ] 투표 생성 트랜잭션 구현
- [ ] 동시 투표 테스트 (동일 proposal에 여러 사용자 동시 투표)
- [ ] (선택) Idempotency 구현

---

### Phase 4: 승인/기각 시스템 ⭐ (상태 전이 + 락 - 필수)

**목표**: Proposal 승인/기각 및 Assumption/Criterion에 반영

**구현 내용:**
- POST /assumptions/proposals/{id}/approve - Assumption 제안 승인
- POST /assumptions/proposals/{id}/reject - Assumption 제안 기각
- POST /criteria/proposals/{id}/approve - Criterion 제안 승인
- POST /criteria/proposals/{id}/reject - Criterion 제안 기각
- POST /conclusions/proposals/{id}/approve - Conclusion 제안 승인
- POST /conclusions/proposals/{id}/reject - Conclusion 제안 기각

**적용할 학습목표:**
1. **상태 전이 (5장)**: `PENDING → ACCEPTED/REJECTED`
   - 비즈니스 로직에서 허용된 상태 전이만 처리
   - 잘못된 상태 전이 시도 시 400 Bad Request
2. **Row-level Lock (4.2.1)**: `SELECT ... FOR UPDATE`
   - Proposal 조회 시 락을 걸어 동시 승인 방지
   - 동시에 여러 요청이 와도 하나만 성공
3. **트랜잭션 (2장)**: 승인 시 여러 작업을 하나로 묶기
   - `proposal_status` 변경
   - `assumptions`/`criterion` 테이블 업데이트
   - `applied_at` 기록
   - 모든 작업이 성공하거나 모두 롤백
4. **Idempotency (6장)**: 승인 요청 중복 방지

**테스트 포인트:**
- 동시에 같은 proposal에 승인 요청 → 하나만 성공, 나머지는 409 Conflict
- `PENDING → REJECTED → ACCEPTED` 같은 잘못된 상태 전이 시도 → 400 Bad Request
- 승인 실패 시 전체 롤백 확인 (proposal_status 변경되지 않음)

**Phase 4 체크리스트:**
- [ ] `SELECT ... FOR UPDATE`로 동시 승인 방지
- [ ] 상태 전이 로직 구현 (허용된 전이만 처리)
- [ ] 승인 시 트랜잭션으로 여러 작업 처리
- [ ] 잘못된 상태 전이 방지
- [ ] (선택) Idempotency 구현

---

### Phase 5: Conclusion 시스템 (Phase 3-4 패턴 재사용)

**목표**: Conclusion 제안/투표/승인 (이미 Phase 2-4에서 구현됨)

**구현 내용:**
- Phase 2-4에서 이미 구현된 conclusion 관련 엔드포인트 활용

**적용할 학습목표:**
- Phase 3-4에서 적용한 패턴 재사용
- 트랜잭션, 동시성, 상태 전이 패턴 동일 적용

**테스트 포인트:**
- Conclusion 제안 → 투표 → 승인 전체 플로우 확인
- Phase 3-4에서 검증한 패턴이 정상 동작하는지 확인

---

### Phase 6: 최종 투표 및 우선순위

**목표**: Answer 투표 + Criterion 우선순위 설정

**구현 내용:**
- POST /answers/{id}/votes - Answer 투표 (Phase 3에서 구현)
- POST /criterion-priorities - Criterion 우선순위 설정
- PUT /criterion-priorities - Criterion 우선순위 수정

**적용할 학습목표:**
- **트랜잭션 (2장)**: 우선순위 설정 시 모든 criterion에 대해 일괄 처리
  - 여러 criterion의 우선순위를 설정할 때 모두 성공하거나 모두 실패
- Phase 3의 투표 패턴 재사용

**테스트 포인트:**
- 최종 투표 시 동시성 테스트
- 우선순위 설정 트랜잭션 테스트 (일부 실패 시 전체 롤백)

---

### Phase 7: 비동기 처리 (Outbox 패턴) 🔶 (선택)

**목표**: 알림, 리포트 생성 등 비동기 작업 처리

**구현 내용:**
- `outbox` 테이블 설계
- 워커 프로세스 구현
- Proposal 승인 시 알림 발송 (비동기)

**적용할 학습목표:**
1. **Outbox 패턴 (9장)**: 트랜잭션 내 outbox 테이블에 작업 기록
   - Proposal 승인 시 `outbox` 테이블에 알림 작업 기록
   - 워커가 주기적으로 `outbox` 읽어 처리
2. **비동기 처리 & 큐 (7장)**: 알림, 리포트 생성 등 비동기 작업
3. **Retry & DLQ (8장)**: 외부 API 실패 시 재시도, 계속 실패하는 작업 별도 보관

**테스트 포인트:**
- Proposal 승인 시 `outbox` 테이블에 알림 작업 기록 확인
- 서버가 죽어도 `outbox` 작업이 유지되는지 확인
- 워커가 `outbox` 작업을 처리하는지 확인
- 외부 API 실패 시 재시도 동작 확인

**Phase 7 체크리스트 (선택):**
- [ ] `outbox` 테이블 설계 및 구현
- [ ] 워커 프로세스 구현
- [ ] 트랜잭션 내 outbox 기록
- [ ] Retry 로직 구현
- [ ] DLQ 개념 구현 (계속 실패하는 작업 별도 보관)

---

### Phase 8: 성능 최적화 🔶 (필요 시)

**목표**: 쿼리 성능 개선

**구현 내용:**
- `EXPLAIN ANALYZE`로 쿼리 분석
- 필요한 인덱스 추가

**적용할 학습목표:**
- **EXPLAIN (10장)**: 쿼리 실행 계획 분석
- 인덱스 추가 전/후 성능 비교

**테스트 포인트:**
- 인덱스 추가 전/후 성능 비교
- `EXPLAIN ANALYZE` 결과 문서화

---

### 단계별 우선순위 정리

**최우선 (필수) - Phase 3**
- 트랜잭션
- UNIQUE 제약 활용

**우선 (필수) - Phase 4**
- Row-level Lock (`SELECT ... FOR UPDATE`)
- 상태 전이 검증

**중기 (권장) - Phase 3-4**
- Idempotency 구현

**장기 (선택) - Phase 7+**
- Outbox 패턴
- 비동기 큐
- Retry/DLQ

**최적화 (필요 시) - Phase 8**
- EXPLAIN 기반 인덱스 최적화

---

## 14. 마무리

이 구조는 특정 기술이나 비즈니스에 종속되지 않습니다.

* 결제
* 예약
* 정산
* 승인
* 포인트
* 초대

어떤 도메인에도 그대로 적용 가능합니다.

> **핵심 메시지:**
> 복잡한 서비스의 본질은 기능이 아니라 **정합성과 신뢰성**이다.
